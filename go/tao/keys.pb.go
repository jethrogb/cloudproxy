// Code generated by protoc-gen-go.
// source: keys.proto
// DO NOT EDIT!

/*
Package tao is a generated protocol buffer package.

It is generated from these files:
	keys.proto

It has these top-level messages:
	CryptoHeader
	CryptoKey
	CryptoKeyset
	PBEData
	ContextualizedData
	SignaturePDU
	SignedData
	EncryptionIntegrityPDU
	EncryptedData
	KeyDerivationPDU
*/
package tao

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CryptoVersion int32

const (
	CryptoVersion_CRYPTO_VERSION_1 CryptoVersion = 1
	CryptoVersion_CRYPTO_VERSION_2 CryptoVersion = 2
)

var CryptoVersion_name = map[int32]string{
	1: "CRYPTO_VERSION_1",
	2: "CRYPTO_VERSION_2",
}
var CryptoVersion_value = map[string]int32{
	"CRYPTO_VERSION_1": 1,
	"CRYPTO_VERSION_2": 2,
}

func (x CryptoVersion) Enum() *CryptoVersion {
	p := new(CryptoVersion)
	*p = x
	return p
}
func (x CryptoVersion) String() string {
	return proto.EnumName(CryptoVersion_name, int32(x))
}
func (x *CryptoVersion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoVersion_value, data, "CryptoVersion")
	if err != nil {
		return err
	}
	*x = CryptoVersion(value)
	return nil
}
func (CryptoVersion) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// CryptoHeader has been changed to include:
// key_name, key_epoch, key_type, key_purpose, key_status (all strings).
// key_epoch is monotonically increasing integer
// key_status: "primary," "pre-primary", "post-primary," "inactive," "revoked"
// key_types:
// 	"aes-128-raw", "aes-256-raw",
// 	"aes128-ctr", "aes256-ctr",
// 	"aes128-ctr-hmacsha256", "aes256-ctr-hmacsha256",
// 	"hmacsha256", "hmacsha384", "hmacsha512",
// 	"rsa1024", "rsa2048", "rsa3072"
// 	"ecdsap256", "ecdsap384", "ecdsap384",
// 	"rsa1024-public", "rsa2048-public", "rsa3072-public"
// 	"ecdsap256-public", "ecdsap384-public"
// 	"hdkf-sha256"
// key_purpose: "verifying", "signing", "crypting", "deriving", "sealing"
type CryptoHeader struct {
	Version          *CryptoVersion `protobuf:"varint,1,req,name=version,enum=tao.CryptoVersion" json:"version,omitempty"`
	KeyName          *string        `protobuf:"bytes,2,opt,name=key_name,json=keyName" json:"key_name,omitempty"`
	KeyEpoch         *int32         `protobuf:"varint,3,opt,name=key_epoch,json=keyEpoch" json:"key_epoch,omitempty"`
	KeyType          *string        `protobuf:"bytes,4,opt,name=key_type,json=keyType" json:"key_type,omitempty"`
	KeyPurpose       *string        `protobuf:"bytes,5,opt,name=key_purpose,json=keyPurpose" json:"key_purpose,omitempty"`
	KeyStatus        *string        `protobuf:"bytes,6,opt,name=key_status,json=keyStatus" json:"key_status,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *CryptoHeader) Reset()                    { *m = CryptoHeader{} }
func (m *CryptoHeader) String() string            { return proto.CompactTextString(m) }
func (*CryptoHeader) ProtoMessage()               {}
func (*CryptoHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CryptoHeader) GetVersion() CryptoVersion {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return CryptoVersion_CRYPTO_VERSION_1
}

func (m *CryptoHeader) GetKeyName() string {
	if m != nil && m.KeyName != nil {
		return *m.KeyName
	}
	return ""
}

func (m *CryptoHeader) GetKeyEpoch() int32 {
	if m != nil && m.KeyEpoch != nil {
		return *m.KeyEpoch
	}
	return 0
}

func (m *CryptoHeader) GetKeyType() string {
	if m != nil && m.KeyType != nil {
		return *m.KeyType
	}
	return ""
}

func (m *CryptoHeader) GetKeyPurpose() string {
	if m != nil && m.KeyPurpose != nil {
		return *m.KeyPurpose
	}
	return ""
}

func (m *CryptoHeader) GetKeyStatus() string {
	if m != nil && m.KeyStatus != nil {
		return *m.KeyStatus
	}
	return ""
}

// CryptoKey
type CryptoKey struct {
	KeyHeader        *CryptoHeader `protobuf:"bytes,1,req,name=key_header,json=keyHeader" json:"key_header,omitempty"`
	KeyComponents    [][]byte      `protobuf:"bytes,2,rep,name=key_components,json=keyComponents" json:"key_components,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *CryptoKey) Reset()                    { *m = CryptoKey{} }
func (m *CryptoKey) String() string            { return proto.CompactTextString(m) }
func (*CryptoKey) ProtoMessage()               {}
func (*CryptoKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *CryptoKey) GetKeyHeader() *CryptoHeader {
	if m != nil {
		return m.KeyHeader
	}
	return nil
}

func (m *CryptoKey) GetKeyComponents() [][]byte {
	if m != nil {
		return m.KeyComponents
	}
	return nil
}

type CryptoKeyset struct {
	Keys [][]byte `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	// Cert for Signing Key
	Cert       []byte            `protobuf:"bytes,2,opt,name=cert" json:"cert,omitempty"`
	Delegation *Attestation `protobuf:"bytes,3,opt,name=delegation" json:"delegation,omitempty"`
	// certs supporting cert from cert signer to authority.
	CertChain        [][]byte `protobuf:"bytes,4,rep,name=cert_chain,json=certChain" json:"cert_chain,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CryptoKeyset) Reset()                    { *m = CryptoKeyset{} }
func (m *CryptoKeyset) String() string            { return proto.CompactTextString(m) }
func (*CryptoKeyset) ProtoMessage()               {}
func (*CryptoKeyset) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CryptoKeyset) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *CryptoKeyset) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *CryptoKeyset) GetDelegation() *Attestation {
	if m != nil {
		return m.Delegation
	}
	return nil
}

func (m *CryptoKeyset) GetCertChain() [][]byte {
	if m != nil {
		return m.CertChain
	}
	return nil
}

// TODO(jlm): Should cipher/hmac be replaced by CryptoHeader?
type PBEData struct {
	Version    *CryptoVersion `protobuf:"varint,1,req,name=version,enum=tao.CryptoVersion" json:"version,omitempty"`
	Cipher     *string        `protobuf:"bytes,2,req,name=cipher" json:"cipher,omitempty"`
	Hmac       *string        `protobuf:"bytes,3,req,name=hmac" json:"hmac,omitempty"`
	Iterations *int32         `protobuf:"varint,4,req,name=iterations" json:"iterations,omitempty"`
	Iv         []byte         `protobuf:"bytes,5,req,name=iv" json:"iv,omitempty"`
	Ciphertext []byte         `protobuf:"bytes,6,req,name=ciphertext" json:"ciphertext,omitempty"`
	// TODO(kwalsh) Should this not use a mac as well for integrity protection?
	Salt             []byte `protobuf:"bytes,7,req,name=salt" json:"salt,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PBEData) Reset()                    { *m = PBEData{} }
func (m *PBEData) String() string            { return proto.CompactTextString(m) }
func (*PBEData) ProtoMessage()               {}
func (*PBEData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *PBEData) GetVersion() CryptoVersion {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return CryptoVersion_CRYPTO_VERSION_1
}

func (m *PBEData) GetCipher() string {
	if m != nil && m.Cipher != nil {
		return *m.Cipher
	}
	return ""
}

func (m *PBEData) GetHmac() string {
	if m != nil && m.Hmac != nil {
		return *m.Hmac
	}
	return ""
}

func (m *PBEData) GetIterations() int32 {
	if m != nil && m.Iterations != nil {
		return *m.Iterations
	}
	return 0
}

func (m *PBEData) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *PBEData) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *PBEData) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

// Contextualized protobuf.
// SECURITY WARNING: Always choose a unique context for each unique type of
// message. One easy way to do this is to number the messages in a protocol
// and make the context "ProtocolName Message Y: ProtobufName Version X"
// Marshaled representation of this is the data that is signed.
type ContextualizedData struct {
	Context          *string `protobuf:"bytes,1,req,name=context" json:"context,omitempty"`
	Data             []byte  `protobuf:"bytes,2,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContextualizedData) Reset()                    { *m = ContextualizedData{} }
func (m *ContextualizedData) String() string            { return proto.CompactTextString(m) }
func (*ContextualizedData) ProtoMessage()               {}
func (*ContextualizedData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ContextualizedData) GetContext() string {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return ""
}

func (m *ContextualizedData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// A PDU including metadata for representing data to be signed.  The data is
// a serialized ContextualizedData message providing unique deserialization.
type SignaturePDU struct {
	Header  *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	Context *string       `protobuf:"bytes,2,req,name=context" json:"context,omitempty"`
	// The serialized ContextualizedData that is to be signed.
	Data             []byte `protobuf:"bytes,3,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SignaturePDU) Reset()                    { *m = SignaturePDU{} }
func (m *SignaturePDU) String() string            { return proto.CompactTextString(m) }
func (*SignaturePDU) ProtoMessage()               {}
func (*SignaturePDU) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SignaturePDU) GetHeader() *CryptoHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SignaturePDU) GetContext() string {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return ""
}

func (m *SignaturePDU) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// The result of signing.
type SignedData struct {
	Header           *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	Signature        []byte        `protobuf:"bytes,2,req,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *SignedData) Reset()                    { *m = SignedData{} }
func (m *SignedData) String() string            { return proto.CompactTextString(m) }
func (*SignedData) ProtoMessage()               {}
func (*SignedData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SignedData) GetHeader() *CryptoHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SignedData) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// A PDU to be serialized and signed for integrity-protection when using
// encryption modes (like AES CTR with HMAC-SHA) that require a separate MAC.
// Note: We actually just hmac the partially serialized EncryptedData message
// with all fields complete except the mac field.
type EncryptionIntegrityPDU struct {
	Header           *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	Iv               []byte        `protobuf:"bytes,2,req,name=iv" json:"iv,omitempty"`
	Ciphertext       []byte        `protobuf:"bytes,3,req,name=ciphertext" json:"ciphertext,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *EncryptionIntegrityPDU) Reset()                    { *m = EncryptionIntegrityPDU{} }
func (m *EncryptionIntegrityPDU) String() string            { return proto.CompactTextString(m) }
func (*EncryptionIntegrityPDU) ProtoMessage()               {}
func (*EncryptionIntegrityPDU) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *EncryptionIntegrityPDU) GetHeader() *CryptoHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *EncryptionIntegrityPDU) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *EncryptionIntegrityPDU) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

// The result of encrypting.
type EncryptedData struct {
	Header           *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	Iv               []byte        `protobuf:"bytes,2,req,name=iv" json:"iv,omitempty"`
	Ciphertext       []byte        `protobuf:"bytes,3,req,name=ciphertext" json:"ciphertext,omitempty"`
	Mac              []byte        `protobuf:"bytes,4,opt,name=mac" json:"mac,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *EncryptedData) Reset()                    { *m = EncryptedData{} }
func (m *EncryptedData) String() string            { return proto.CompactTextString(m) }
func (*EncryptedData) ProtoMessage()               {}
func (*EncryptedData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *EncryptedData) GetHeader() *CryptoHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *EncryptedData) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *EncryptedData) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *EncryptedData) GetMac() []byte {
	if m != nil {
		return m.Mac
	}
	return nil
}

// A PDU to be serialized and fed to HKDF for derivation.
type KeyDerivationPDU struct {
	PreviousHash     []byte  `protobuf:"bytes,1,req,name=previous_hash,json=previousHash" json:"previous_hash,omitempty"`
	Size             *uint32 `protobuf:"fixed32,2,req,name=size" json:"size,omitempty"`
	Context          *string `protobuf:"bytes,3,req,name=context" json:"context,omitempty"`
	Index            *uint32 `protobuf:"fixed32,4,req,name=index" json:"index,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *KeyDerivationPDU) Reset()                    { *m = KeyDerivationPDU{} }
func (m *KeyDerivationPDU) String() string            { return proto.CompactTextString(m) }
func (*KeyDerivationPDU) ProtoMessage()               {}
func (*KeyDerivationPDU) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *KeyDerivationPDU) GetPreviousHash() []byte {
	if m != nil {
		return m.PreviousHash
	}
	return nil
}

func (m *KeyDerivationPDU) GetSize() uint32 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *KeyDerivationPDU) GetContext() string {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return ""
}

func (m *KeyDerivationPDU) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func init() {
	proto.RegisterType((*CryptoHeader)(nil), "tao.CryptoHeader")
	proto.RegisterType((*CryptoKey)(nil), "tao.CryptoKey")
	proto.RegisterType((*CryptoKeyset)(nil), "tao.CryptoKeyset")
	proto.RegisterType((*PBEData)(nil), "tao.PBEData")
	proto.RegisterType((*ContextualizedData)(nil), "tao.ContextualizedData")
	proto.RegisterType((*SignaturePDU)(nil), "tao.SignaturePDU")
	proto.RegisterType((*SignedData)(nil), "tao.SignedData")
	proto.RegisterType((*EncryptionIntegrityPDU)(nil), "tao.EncryptionIntegrityPDU")
	proto.RegisterType((*EncryptedData)(nil), "tao.EncryptedData")
	proto.RegisterType((*KeyDerivationPDU)(nil), "tao.KeyDerivationPDU")
	proto.RegisterEnum("tao.CryptoVersion", CryptoVersion_name, CryptoVersion_value)
}

/*
func init() { proto.RegisterFile("keys.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 623 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x53, 0x5f, 0x6b, 0xdb, 0x5e,
	0x0c, 0x25, 0x76, 0x5b, 0xff, 0xac, 0x26, 0xc5, 0xbd, 0xfc, 0x28, 0xde, 0xff, 0xe2, 0x31, 0xe8,
	0xc6, 0x28, 0x5b, 0x5e, 0xf7, 0xb4, 0xa6, 0x81, 0x96, 0x41, 0x1b, 0x9c, 0xb6, 0xb0, 0x27, 0x73,
	0xb1, 0x2f, 0xb1, 0x59, 0x62, 0x1b, 0xdf, 0x9b, 0xd0, 0x6c, 0x7b, 0xdf, 0x47, 0xdb, 0xe3, 0xbe,
	0xd2, 0x24, 0xd9, 0x49, 0xdd, 0xd1, 0x31, 0xf2, 0x26, 0x1d, 0x49, 0xf7, 0xe8, 0x48, 0xba, 0x00,
	0x5f, 0xd4, 0x52, 0x1f, 0x97, 0x55, 0x61, 0x0a, 0x61, 0x1b, 0x59, 0x3c, 0xde, 0x97, 0xc6, 0x28,
	0x6d, 0xa4, 0xc9, 0x8a, 0xbc, 0xc6, 0x83, 0x5f, 0x1d, 0xe8, 0x0e, 0xaa, 0x65, 0x69, 0x8a, 0x33,
	0x25, 0x13, 0x55, 0x89, 0xb7, 0xe0, 0x2c, 0x54, 0xa5, 0x31, 0xc3, 0xef, 0x1c, 0x5a, 0x47, 0x7b,
	0x7d, 0x71, 0x8c, 0xa5, 0xc7, 0x75, 0xce, 0x4d, 0x1d, 0x09, 0x57, 0x29, 0xe2, 0x11, 0xfc, 0x87,
	0x24, 0x51, 0x2e, 0x67, 0xca, 0xb7, 0x0e, 0x3b, 0x47, 0x6e, 0xe8, 0xa0, 0x7f, 0x81, 0xae, 0x78,
	0x02, 0x2e, 0x85, 0x54, 0x59, 0xc4, 0xa9, 0x6f, 0x63, 0x6c, 0x3b, 0xa4, 0xdc, 0x21, 0xf9, 0xab,
	0x3a, 0xb3, 0x2c, 0x95, 0xbf, 0xb5, 0xae, 0xbb, 0x42, 0x57, 0xbc, 0x80, 0x5d, 0x0a, 0x95, 0xf3,
	0xaa, 0x2c, 0xb4, 0xf2, 0xb7, 0x39, 0x4a, 0x52, 0x46, 0x35, 0x22, 0x9e, 0xb1, 0xb0, 0x88, 0x74,
	0xcc, 0xb5, 0xbf, 0xc3, 0x71, 0xa2, 0x1a, 0x33, 0x10, 0x24, 0xe0, 0xd6, 0xcd, 0x7e, 0x52, 0x4b,
	0xf1, 0xae, 0xce, 0x4d, 0x59, 0x1b, 0x0b, 0xda, 0xed, 0xef, 0xb7, 0x04, 0xd5, 0xa2, 0xb9, 0xbc,
	0xd1, 0xff, 0x0a, 0xf6, 0xa8, 0x22, 0x2e, 0x66, 0x65, 0x91, 0xab, 0xdc, 0x68, 0xd4, 0x65, 0x1f,
	0x75, 0xc3, 0x1e, 0xa2, 0x83, 0x35, 0x18, 0xfc, 0x58, 0xcf, 0x0d, 0x69, 0xb4, 0x32, 0x42, 0xc0,
	0x16, 0x8d, 0x1b, 0x39, 0x28, 0x9b, 0x6d, 0xc2, 0x62, 0x55, 0x19, 0x9e, 0x0c, 0x62, 0x64, 0x53,
	0x47, 0x89, 0x9a, 0xaa, 0x09, 0x2f, 0x81, 0xe7, 0xb2, 0xdb, 0xf7, 0xb8, 0xa3, 0x8f, 0x77, 0xcb,
	0x09, 0x5b, 0x39, 0xa4, 0x97, 0x2a, 0xa3, 0x38, 0x95, 0x59, 0x8e, 0xd3, 0xa2, 0xf7, 0x5d, 0x42,
	0x06, 0x04, 0x04, 0x3f, 0x3b, 0xe0, 0x8c, 0x4e, 0x86, 0xa7, 0xd2, 0xc8, 0x0d, 0x97, 0x77, 0x00,
	0x3b, 0x71, 0x56, 0xa6, 0x38, 0x18, 0x0b, 0x93, 0xdd, 0xb0, 0xf1, 0xa8, 0xed, 0x74, 0x26, 0x63,
	0x6c, 0x8e, 0x50, 0xb6, 0xc5, 0x73, 0x80, 0xcc, 0xa8, 0x8a, 0x3b, 0xd2, 0xd8, 0x84, 0x85, 0xeb,
	0x6c, 0x21, 0x62, 0x0f, 0xac, 0x6c, 0x81, 0xcb, 0xb2, 0xb0, 0x39, 0xb4, 0x28, 0xbf, 0x7e, 0xcd,
	0xa8, 0x5b, 0x83, 0x4b, 0x22, 0xbc, 0x85, 0x10, 0x87, 0x96, 0x53, 0xe3, 0x3b, 0x1c, 0x61, 0x3b,
	0x38, 0x01, 0x31, 0x28, 0x72, 0x0a, 0xcf, 0xe5, 0x34, 0xfb, 0xaa, 0x12, 0xd6, 0xe4, 0x83, 0x13,
	0xd7, 0x28, 0x6b, 0xc2, 0x4b, 0x69, 0x5c, 0x7a, 0x23, 0xc1, 0x0c, 0xee, 0x1e, 0xdf, 0x20, 0x3b,
	0x98, 0x40, 0x77, 0x9c, 0x4d, 0x72, 0xbc, 0x84, 0x4a, 0x8d, 0x4e, 0xaf, 0xc5, 0x6b, 0xd8, 0xf9,
	0xd7, 0xf2, 0x9b, 0x84, 0x36, 0x91, 0xf5, 0x30, 0x91, 0xdd, 0x22, 0xba, 0x06, 0x20, 0xa2, 0xa6,
	0xc9, 0x0d, 0x68, 0x9e, 0x82, 0xab, 0x57, 0x1d, 0x36, 0xad, 0xdf, 0x01, 0x81, 0x86, 0x83, 0x61,
	0x1e, 0x53, 0x1d, 0x8e, 0xf5, 0x1c, 0xe9, 0x27, 0x55, 0x66, 0x96, 0x1b, 0x2a, 0xa9, 0x97, 0x61,
	0xfd, 0x65, 0x19, 0xf6, 0x9f, 0xcb, 0x08, 0xbe, 0x43, 0xaf, 0x21, 0xdd, 0x5c, 0xce, 0x86, 0x5c,
	0xc2, 0x03, 0x9b, 0x6e, 0x6b, 0x8b, 0xbf, 0x04, 0x99, 0xc1, 0x37, 0xf0, 0xf0, 0x0f, 0x9d, 0xaa,
	0x2a, 0x5b, 0xf0, 0x31, 0x91, 0xd8, 0x97, 0xd0, 0x2b, 0x2b, 0xb5, 0xc8, 0x8a, 0xb9, 0x8e, 0x52,
	0xa9, 0x53, 0xee, 0xa3, 0x1b, 0x76, 0x57, 0xe0, 0x19, 0x62, 0x7c, 0x43, 0x78, 0x26, 0x4c, 0xee,
	0x84, 0x6c, 0xb7, 0x97, 0x68, 0xdf, 0x5f, 0xe2, 0xff, 0xb0, 0x9d, 0xe5, 0x89, 0xba, 0xe5, 0xe3,
	0x75, 0xc2, 0xda, 0x79, 0xf3, 0x01, 0x7a, 0xf7, 0x7e, 0x07, 0xa6, 0x79, 0x83, 0xf0, 0xf3, 0xe8,
	0xea, 0x32, 0xba, 0x19, 0x86, 0xe3, 0xf3, 0xcb, 0x8b, 0xe8, 0xbd, 0xd7, 0x79, 0x00, 0xed, 0x7b,
	0xd6, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x77, 0x44, 0x80, 0x7b, 0x61, 0x05, 0x00, 0x00,
}
*/
