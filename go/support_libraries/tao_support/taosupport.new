// Copyright (c) 2014, Google, Inc..  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//     http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// File: taosupport.go

package tao_support

import (
	"crypto/tls"
	"crypto/x509"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"strings"

	"github.com/golang/protobuf/proto"

	"github.com/jlmucb/cloudproxy/go/support_infrastructure/domain_service"
	"github.com/jlmucb/cloudproxy/go/support_libraries/domain_policy"
	"github.com/jlmucb/cloudproxy/go/tao"
	"github.com/jlmucb/cloudproxy/go/tao/auth"
	"github.com/jlmucb/cloudproxy/go/util"
)

type TaoProgramData struct {
	// true after initialization.
	Initialized bool

	// Program name.
	TaoName string

	// DER encoded policy cert for domain.
	PolicyCert []byte

	// Program Signing key.
	ProgramSigningKey *tao.Signer

	// Program Crypting Key.
	ProgramCryptingKey *tao.Crypter

	// Program Cert.
	ProgramCert []byte

	// Cert Chain
	CertChain [][]byte

	// Path for program to read and write files.
	ProgramFilePath *string
}

// This is not used now but Cloudproxy principals are in the Organization name.
func PrincipalNameFromDERCert(derCert []byte) *string {
	cert, err := x509.ParseCertificate(derCert)
	if err != nil {
		log.Printf("PrincipalNameFromDERCert: Can't get name from certificate\n")
		return nil
	}
	var name string
	if len(cert.Subject.Organization) > 0 && cert.Subject.Organization[0] != "" {
		name = cert.Subject.Organization[0]
	} else {
		name = cert.Subject.CommonName
	}
	return &name
}

func (pp *TaoProgramData) ClearTaoProgramData() {
	pp.Initialized = false
	pp.KeySetType = ""
	tao.ZeroBytes([]byte(pp.TaoName))
	tao.ZeroBytes(pp.PolicyCert)
	if pp.ProgramSigningKey != nil {
		// TODO(manferdelli): find out how to clear signingkey.
		// tao.ZeroBytes([]byte(*pp.ProgramKey))
	}
	if pp.ProgramCryptingKey != nil {
		// TODO(manferdelli): find out how to clear signingkey.
	}
	tao.ZeroBytes(pp.ProgramCert)
	pp.ProgramFilePath = nil
}

// RequestDomainServiceCert requests the signed Program Cert from SimpleDomainService
func RequestDomainServiceCert(network, addr string, requesting_key *tao.Keys,
	v *tao.Verifier) (*domain_policy.DomainCertResponse, error) {

	// Note requesting program key contains a self-signed cert to open channel.
	if requesting_key.Cert == nil {
		return nil, errors.New("RequestDomainServiceCert: Can't dial with an empty client certificate")
	}

log.Printf("RequestDomainServiceCert Requestor Cert: \n")
tao.PrintPKIXName("Subject", &requesting_key.Cert.Subject)
log.Printf("\n")

	tlsCert, err := tao.EncodeTLSCert(requesting_key)
	if err != nil {
		return nil, err
	}
	conn, err := tls.Dial(network, addr, &tls.Config{
		RootCAs:            x509.NewCertPool(),
		Certificates:       []tls.Certificate{*tlsCert},
		InsecureSkipVerify: true,
	})
	if err != nil {
		return nil, err
	}
	defer conn.Close()

	var request domain_policy.DomainCertRequest
	request.Attestation, err = proto.Marshal(requesting_key.Delegation)
	request.KeyType = requesting_key.SigningKey.Header.KeyType
	request.SubjectPublicKey, err = requesting_key.SigningKey.CanonicalKeyBytesFromSigner()
	if err != nil {
		return nil, err
	}

	// Tao handshake: send client delegation.
	ms := util.NewMessageStream(conn)
	_, err = ms.WriteMessage(&request)
	if err != nil {
		return nil, err
	}

	// Read the new cert
	var response domain_policy.DomainCertResponse
	err = ms.ReadMessage(&response)
	if err != nil {
		return nil, err
	}
	return &response, nil
}

func SealMaterial(material []byte) ([]byte, error) {
	return tao.Parent().Seal(material, tao.SealPolicyDefault)
}

func UnsealMaterial(material []byte) ([]byte, error) {
	unsealed, _, err := tao.Parent().Unseal(material)
	return unsealed, err
}

func SerializeProgramData(programData *ProgramData) ([]byte, error) {
	var pd SavedProgramData
	pd.FilePath = programData.ProgramFilePath
	pd.PolicyCert = programData.PolicyCert
	pd.ProgramName= programData.TaoName
	pd.CryptoSuite = tao.TaoCryptoSuite
	pd.SignerCertChain = append(pd.SignerCertChain, programData.ProgramCert)
	for i := 0; i < programData.CertChain; i++ {
		pd.SignerCertChain = append(pd.SignerCertChain, programData.CertChain[i])
	}
	sck, err := CryptoKeyFromSigner(programData.ProgramSigningKey)
	if err != nil {
		return nil, errors.New("Can't get CryptoKey from signer")
	}
	cck, err := CryptoKeyFromCrypter(programData.ProgramCryptingKey)
	if err != nil {
		return nil, errors.New("Can't get CryptoKey from crypter")
	}
	pd.SigningKeyBlob = MarshalCryptoKey(sck)
	pd.CryptingKeyBlob = MarshalCryptoKey(cck)
	unsealed, err := proto.Marshal(pd)
	if err != nil {
		return nil, errors.New("Can't marshal SavedProgramData")
	}
	sealed, err := SealMaterial(unsealed)
	if err != nil {
		return nil, errors.New("Can't seal marshalled SavedProgramData")
	}
	return sealed, nil
}

func SaveProgramData(fileName string, programObject *TaoProgramData) error {
	b, err := SerializeProgramData(programObject)
	if err != nil {
		return errors.New("Can't SerializeProgramData")
	}
	err = ioutil.WriteFile(fileName, sealed,  os.ModePerm)
	if err != nil {
		return errors.New("Error writing program data")
	}
	return nil
}

func InitProgramKeys(programData *ProgramData) error {
	signerKeyType := tao.SignerTypeFromSuiteName(tao.TaoCryptoSuite)
	if signerKeyType == nil {
		return errors.New(fmt.Sprintln("TaoParadigm: Can't get signer type\n"))
	}
	crypterKeyType := tao.CrypterTypeFromSuiteName(tao.TaoCryptoSuite)
	if crypterKeyType == nil {
		return errors.New(fmt.Sprintln("TaoParadigm: Can't get crypter type\n"))
	}
	symTotalKeySize := tao.CombinedKeySizeFromAlgorithmName(*crypterKeyType)
	if symTotalKeySize == nil {
		return errors.New(fmt.Sprintln("TaoParadigm: Can't get crypto suite crypter size\n"))
	}
	keyName := path.Join(programData.TaoName, "_Signer")
	keyEpoch := int32(1)
	keyPurpose := "signing"
	keyStatus := "active"
	sck := GenerateCryptoKey(*signerKeyType, &keyName, &keyEpoch, &keyPurpose, &keyStatus)
	if sck == nil {
	}
	programData.ProgramSigningKey = SignerFromCryptoKey(sck)
	keyName = path.Join(programData.TaoName, "_Crypter")
	keyPurpose = "crypting"
	cck := GenerateCryptoKey(*crypterKeyType, &keyName, &keyEpoch, &keyPurpose, &keyStatus)
	if cck == nil {
	}
	programData.ProgramCryptingKey = CrypterFromCryptoKey(cck)
	retrun nil
}

func DeserializeProgramData(buf []byte, programObject *TaoProgramData) error {
	unsealed, err := UnsealMaterial(programInfoBlob)
	if err != nil {
		return errors.New("Can't unseal program material")
	}
	var savedProgramData SavedProgramData
	err = proto.Unmarshal(unsealed, &savedProgramData)
	if err != nil {
		return errors.New("Can't unmarshal program material")
	}
	if savedProgramData.FilePath !=  nil && programObject.FilePath != nil &&
		*programObject.FilePath != *savedProgramData.ProgramFilePath {
	}
	if savedProgramData.PolicyCert !=  nil && programObject.PolicyCert != nil &&
		*programObject.PolicyCert != *savedProgramData.PolicyCert {
	}
	if savedProgramData.ProgramName !=  nil && 
		programObject.TaoName != savedProgramData.ProgramName {
	}
	if savedProgramData.CryptoSuite !=  nil && 
		*savedProgramData.CryptoSuite != tao.TaoCryptoSuite {
	}
	sck, err := UnmarshalCryptoKey(savedProgramData.SigningKeyBlob)
	if err != nil {
		return errors.New("Can't get cryptokey for signing key")
	}
	programObject.ProgramSigningKey = SignerFromCryptoKey(ck)
	cck, err := UnmarshalCryptoKey(savedProgramData.CryptingKeyBlob)
	if err != nil {
		return errors.New("Can't get cryptokey for crypting key")
	}
	programObject.ProgramCryptingKey = CrypterFromCryptoKey(ck)

	if (len(savedProgramData.SignerCertChain) > 0 {
		programObject.ProgramCert = SavedProgramData.SignerCertChain[0]
	}

	for i := 0; i < len(savedProgramData.SignerCertChain) - 1; i++ {
		programObject.CertChain= append(programObject.CertChain, SavedProgramData.SignerCertChain[i + 1])
	}
	return nil
}

func GetProgramData(path string, programObject *TaoProgramData) error {

	fileName := path.Join(filePath, "protectedProgramKeys")
	programInfoBlob, err := ioutil.ReadFile(fileName)
	if err != nil {
		err = DeserializeProgramData(programInfoBlob, programObject)
		if err != nil {
		}
	} else {
		err := InitProgramData(programObject)
		if err != nil {
		}
		_= SaveProgramData(fileName, programObject)
	}
	return nil
}

// cfg is policy domain config info
// filePath is path to program data
func TaoParadigm(cfg *string, filePath *string, useSimpleDomainService bool, caAddr string,
	programObject *TaoProgramData) error {

	// Load domain info for this domain.
	simpleDomain, err := tao.LoadDomain(*cfg, nil)
	if err != nil {
		return errors.New(fmt.Sprintln("TaoParadigm: Can't load domain. Error: ", err))
	}

	// Get policy cert.
	if simpleDomain.Keys.Cert == nil || simpleDomain.Keys.Cert.Raw == nil {
		return errors.New("TaoParadigm: Can't retrieve policy cert")
	}
	programObject.PolicyCert = simpleDomain.Keys.Cert.Raw


	// Extend tao name with policy key
	err = simpleDomain.ExtendTaoName(tao.Parent())
	if err != nil {
		return errors.New(fmt.Sprintln("TaoParadigm: Error extending name: ", err))
	}

	// Retrieve extended name.
	taoName, err := tao.Parent().GetTaoName()
	if err != nil {
		return errors.New(fmt.Sprintln("TaoParadigm: Can't extend Tao Principal name. Error: ", err))
	}
	log.Printf("TaoParadigm: my name is %s\n", taoName)
	programObject.TaoName = taoName
	programObject.ProgramFilePath = filePath 

	err = GetProgramData(filePath, programObject)
	if err != nil {
		return err
	}
	programObject.Initialized = true
	return nil
}

// Establishes the Tao Channel for a client using the Program Key.
// This program does all the standard client side channel negotiation.
// After negotiation is complete.  ms is the bi-directional confidentiality and
// integrity protected channel.  OpenTaoChannel returns the stream (ms) for subsequent reads
// and writes as well as the server's Tao Principal Name.
func OpenTaoChannel(programObject *TaoProgramData, serverAddr *string) (
	*util.MessageStream, *string, error) {

	// Parse policy cert and make it the root of our
	// hierarchy for verifying Tao Channel peer.
	policyCert, err := x509.ParseCertificate(programObject.PolicyCert)
	if err != nil {
		return nil, nil, errors.New("OpenTaoChannel: Can't ParseCertificate")
	}
	pool := x509.NewCertPool()
	pool.AddCert(policyCert)

	// Open the Tao Channel using the Program key.
fmt.Printf("Program key:\n")
tao.PrintKeys(&programObject.ProgramKey)
	tlsc, err := tao.EncodeTLSCert(&programObject.ProgramKey)
	if err != nil {
		log.Fatalln("OpenTaoChannel, encode error: ", err)
	}
	// TODO(manferdelli): Replace this with tao.Dial?
	conn, err := tls.Dial("tcp", *serverAddr, &tls.Config{
		RootCAs:            pool,
		Certificates:       []tls.Certificate{*tlsc},
		InsecureSkipVerify: false,
	})
	if err != nil {
		fmt.Printf("OpenTaoChannel: Can't establish channel : %v\n", err)
		return nil, nil, errors.New("OpenTaoChannel: Can't establish channel")
	}

	peerName := policyCert.Subject.OrganizationalUnit[0]

	// Stream for Tao Channel.
	ms := util.NewMessageStream(conn)
	return ms, &peerName, nil
}

func SerializeKeys(programData *TaoProgramData) ([]byte, error) {
}

func SealData(material []byte) ([]byte, error) {
}

func UnsealData(material []byte) ([]byte, error) {
}

func SaveProgramData(filePath string, programData *TaoProgramData) bool {
}

func RecoverProgramData(filePath string, programData *TaoProgramData) bool {
	_, err := os.Stat(path.Join(filePath, "savedKeys"))
	if err != nil {
		// Keys exist
	}
}

func InitProgramData(t tao.Tao, programData *TaoProgramData) bool {
	self, err := t.GetTaoName()
	k, err := tao.NewTemporaryKeys(tao.Signing | tao.Crypting)
	if k == nil || err != nil {
		return nil, nil, errors.New("Can't generate keys")
	}
}

// Create a Program Public/Private key.
func CreateSigningKey(t tao.Tao) (*tao.Keys, []byte, error) {

	self, err := t.GetTaoName()
	k, err := tao.NewTemporaryKeys(tao.Signing)
	if k == nil || err != nil {
		return nil, nil, errors.New("Can't generate signing key")
	}

	publicString := strings.Replace(self.String(), "(", "", -1)
	publicString = strings.Replace(publicString, ")", "", -1)

	// publicString is now a canonicalized Tao Principal name
	us := "US"
	google := "Google"
	details := tao.X509Details{
		Country:      &us,
		Organization: &google,
		CommonName:   &publicString}
	subjectname := tao.NewX509Name(&details)

	keyType := k.SigningKey.Header.KeyType
	pkInt := tao.PublicKeyAlgFromSignerAlg(*keyType)
	sigInt := tao.SignatureAlgFromSignerAlg(*keyType)

	cert, err := k.SigningKey.CreateSelfSignedX509(pkInt, sigInt, int64(1), subjectname)
	if err != nil {
		return nil, nil, err
	}

	// Construct statement: "ProgramKey (new key) speaksfor Principal Name"
	// ToPrincipal retrieves key's Tao Principal Name.
	k.Cert = cert
	s := &auth.Speaksfor{
		Delegate:  k.SigningKey.ToPrincipal(),
		Delegator: self}
	if s == nil {
		return nil, nil, errors.New("Can't produce speaksfor")
	}

	// Sign attestation statement
	k.Delegation, err = t.Attest(&self, nil, nil, s)
	if err != nil {
		return nil, nil, err
	}
	_, _ = auth.UnmarshalForm(k.Delegation.SerializedStatement)
	return k, k.Cert.Raw, nil
}

// Obtain a signing private key (usually a Program Key) from a sealed blob.
func SigningKeyFromBlob(t tao.Tao, sealedKeyBlob []byte, programCert []byte) (*tao.Keys, error) {

	// Recover public key from blob
	k := &tao.Keys{}

	cert, err := x509.ParseCertificate(programCert)
	if err != nil {
		return nil, err
	}

	/*
		 * We don't use this now.
		k.Delegation = new(tao.Attestation)
		err = proto.Unmarshal(delegateBlob, k.Delegation)
		if err != nil {
			return nil, err
		}
	*/

	signingKeyBlob, policy, err := tao.Parent().Unseal(sealedKeyBlob)
	if err != nil {
		return nil, err
	}
	if policy != tao.SealPolicyDefault {
		return nil, err
	}
	k.SigningKey, err = tao.UnmarshalSignerDER(signingKeyBlob)
	k.Cert = cert
	k.Cert.Raw = programCert
	return k, err
}
