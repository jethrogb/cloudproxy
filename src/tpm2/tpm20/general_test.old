// Copyright (c) 2014, Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tpm

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"reflect"
	"testing"
)

func TestDecode(t *testing.T) {
	x, err := ConstructGetRandom(16)
	if err != nil {
		fmt.Printf("TestDecode fails\n")
		return
	}
	fmt.Printf("TestDecode Constructed command: %x\n", x)
	var a1 uint16 
	var a2 uint32
	var a3 uint32
	var a4 uint32
	out :=  []interface{}{&a1, &a2, &a3, &a4}
	err = unpack(x, out)
	if err != nil {
		fmt.Printf("unpack breaks\n")
		return
	}
	for _, e := range out {
		v := reflect.ValueOf(e)
                switch v.Kind() {
		case reflect.Ptr:
			switch(reflect.Indirect(v).Kind()) {
			case reflect.Uint16:
				u := reflect.Indirect(v)
				t, ok := u.Interface().(uint16)
				if ok != true {
					fmt.Printf("Not OK\n")
					return
				}
				fmt.Printf("uint16 subcase: %x\n", t)
			case reflect.Uint32:
				u := reflect.Indirect(v)
				t, ok := u.Interface().(uint32)
				if ok != true {
					fmt.Printf("Not OK\n")
					return
				}
				fmt.Printf("uint32 subcase: %x\n", t)
			default:
				fmt.Printf("default subcase\n")
			}
		default:
			fmt.Printf("default case\n")
		}
	}
}

